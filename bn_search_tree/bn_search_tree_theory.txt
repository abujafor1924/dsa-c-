নিশ্চয়! এখানে **বাইনারি সার্চ ট্রি (Binary Search Tree - BST)** এর সম্পূর্ণ বাংলা টিউটোরিয়াল দেওয়া হলো। আমি সহজ ভাষায় এবং উদাহরণ দিয়ে বুঝানোর চেষ্টা করেছি।

## বাইনারি সার্চ ট্রি কি? (What is a Binary Search Tree?)

**বাইনারি সার্চ ট্রি** হলো একটি বিশেষ ধরনের **বাইনারি ট্রি** ডাটা স্ট্রাকচার, যেখানে প্রতিটি নোডের (node) সর্বোচ্চ দুইটি চাইল্ড (child) নোড থাকে - বাম (left) এবং ডান (right)। এর একটি বিশেষ বৈশিষ্ট্য হলো এটি একটি **সাজানো (sorted)** কাঠামো বজায় রাখে।

### সহজ বাংলায় সংজ্ঞা:

> "একটি বাইনারি সার্চ ট্রিতে, কোনো নোডের **বাম সাবট্রি**-এর সবগুলো নোডের মান সেই নোডের মানের থেকে **ছোট** হয় এবং **ডান সাবট্রি**-এর সবগুলো নোডের মান সেই নোডের মানের থেকে **বড়** হয়।"

---

## BST এর মৌলিক বৈশিষ্ট্য (Basic Properties)

১. **প্রতিটি নোডের সর্বোচ্চ ২টি চাইল্ড** (বাম ও ডান)
২. **বাম সাবট্রি**-এর সব মান < **মূল নোড**-এর মান
৩. **ডান সাবট্রি**-এর সব মান > **মূল নোড**-এর মান
৪. **ডুপ্লিকেট ভ্যালু** সাধারণত অনুমোদিত নয়

---

## BST এর অপারেশনগুলো (Operations in BST)

### ১. সার্চ (Search) - খুঁজে বের করা

**অ্যালগরিদম:**
- রুট নোড থেকে শুরু করুন
- টার্গেট ভ্যালু যদি রুটের সমান হয় → পেয়ে গেছেন!
- টার্গেট ভ্যালু যদি রুটের থেকে ছোট হয় → বাম সাবট্রিতে খুঁজুন
- টার্গেট ভ্যালু যদি রুটের থেকে বড় হয় → ডান সাবট্রিতে খুঁজুন

**উদাহরণ:** ট্রিতে ২৫ খুঁজতে চাই
```
        ৫০
       /  \
     ৩০   ৭০
    / \   / \
  ২০  ৪০ ৬০ ৮০
```

স্টেপগুলো:
১. ৫০ এর সাথে তুলনা → ২৫ < ৫০ → বামে যান
২. ৩০ এর সাথে তুলনা → ২৫ < ৩০ → বামে যান  
৩. ২০ এর সাথে তুলনা → ২৫ > ২০ → ডানে যান
৪. ২৫ পেয়ে গেছেন!

### ২. ইনসার্ট (Insert) - নতুন নোড যোগ করা

**অ্যালগরিদম:**
- রুট থেকে শুরু করুন
- ভ্যালু অনুযায়ী বাম/ডান সাবট্রিতে যান
- খালি জায়গা পেলে সেখানে নতুন নোড যোগ করুন

**উদাহরণ:** ৩৫ যোগ করতে চাই
```
        ৫০
       /  \
     ৩০   ৭০
    / \   / \
  ২০  ৪০ ৬০ ৮০
```

স্টেপগুলো:
১. ৫০ → ৩৫ < ৫০ → বামে
২. ৩০ → ৩৫ > ৩০ → ডানে  
৩. ৪০ → ৩৫ < ৪০ → বামে
৪. খালি জায়গা → ৩৫ যোগ করুন

ফলাফল:
```
        ৫০
       /  \
     ৩০   ৭০
    / \   / \
  ২০  ৪০ ৬০ ৮০
      /
     ৩৫
```

### ৩. ডিলিট (Delete) - নোড মুছে ফেলা

**৩টি কেস হতে পারে:**

**কেস ১: লিফ নোড (কোন চাইল্ড নেই)**
- সরাসরি মুছে ফেলুন

**কেস ২: একটি চাইল্ড আছে**
- নোড মুছে দিয়ে তার চাইল্ডকে তার জায়গায় বসান

**কেস ৩: দুইটি চাইল্ড আছে**
- নোডের **ইনঅর্ডার সাকসেসর** (ডান সাবট্রির সবচেয়ে ছোট নোড) খুঁজুন
- সাকসেসরের ভ্যালু নিয়ে আসুন
- সাকসেসরকে মুছে ফেলুন

---

## BST ট্রাভারসাল (Traversal)

### ১. ইনঅর্ডার ট্রাভারসাল (Inorder Traversal)
**সূত্র:** Left → Root → Right  
**ফলাফল:** সাজানো ডাটা (Ascending Order)

### ২. প্রি-অর্ডার ট্রাভারসাল (Preorder Traversal)  
**সূত্র:** Root → Left → Right
**ফলাফল:** ট্রি কপি করতে有用

### ৩. পোস্ট-অর্ডার ট্রাভারসাল (Postorder Traversal)
**সূত্র:** Left → Right → Root
**ফলাফল:** ট্রি ডিলিট করতে有用

---

## BST এর সুবিধা (Advantages)

✅ **দ্রুত সার্চ:** O(h) টাইম কমপ্লেক্সিটি (h = ট্রির উচ্চতা)  
✅ **দ্রুত ইনসার্ট/ডিলিট:** O(h) টাইম  
✅ **ডায়নামিক সাইজ:** অ্যারের মতো সাইজ ফিক্সড নয়  
✅ **সাজানো ডাটা:** ইনঅর্ডার ট্রাভারসালে সাজানো ডাটা পাবেন

---

## BST এর অসুবিধা (Disadvantages)

❌ **ব্যালান্স না হলে পারফরম্যান্স খারাপ:** সবচেয়ে খারাপ কেস O(n)  
❌ **ব্যালান্স ট্রি মেইনটেইন করা কঠিক**  
❌ **ডুপ্লিকেট ভ্যালু সাপোর্ট করে না** (সাধারণত)

---

## কোড উদাহরণ (C ভাষায়)

```c
#include <stdio.h>
#include <stdlib.h>

// BST নোড স্ট্রাকচার
struct Node {
    int data;
    struct Node* left;
    struct Node* right;
};

// নতুন নোড তৈরি
struct Node* createNode(int value) {
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    newNode->data = value;
    newNode->left = NULL;
    newNode->right = NULL;
    return newNode;
}

// ইনসার্ট ফাংশন
struct Node* insert(struct Node* root, int value) {
    if (root == NULL) {
        return createNode(value);
    }
    
    if (value < root->data) {
        root->left = insert(root->left, value);
    } else if (value > root->data) {
        root->right = insert(root->right, value);
    }
    
    return root;
}

// ইনঅর্ডার ট্রাভারসাল
void inorder(struct Node* root) {
    if (root != NULL) {
        inorder(root->left);
        printf("%d ", root->data);
        inorder(root->right);
    }
}

// সার্চ ফাংশন
struct Node* search(struct Node* root, int value) {
    if (root == NULL || root->data == value) {
        return root;
    }
    
    if (value < root->data) {
        return search(root->left, value);
    }
    
    return search(root->right, value);
}

// মেইন ফাংশন
int main() {
    struct Node* root = NULL;
    
    // নোড যোগ করা
    root = insert(root, 50);
    insert(root, 30);
    insert(root, 20);
    insert(root, 40);
    insert(root, 70);
    insert(root, 60);
    insert(root, 80);
    
    printf("Inorder traversal: ");
    inorder(root);  // আউটপুট: 20 30 40 50 60 70 80
    
    // সার্চ উদাহরণ
    int key = 40;
    if (search(root, key) != NULL) {
        printf("\n%d found in BST", key);
    } else {
        printf("\n%d not found in BST", key);
    }
    
    return 0;
}
```

---

## রিয়েল-লাইফ উদাহরণ (Real-life Examples)

১. **ডিকশনারি ইমপ্লিমেন্টেশন** - শব্দ খোঁজার জন্য
২. **ফাইল সিস্টেম** - ডিরেক্টরি স্ট্রাকচার
৩. **ডাটাবেস ইন্ডেক্সিং** - দ্রুত ডাটা রিট্রিভ করার জন্য
৪. **নেটওয়ার্ক রাউটিং** - আইপি অ্যাড্রেস লুকআপ

---

## গুরুত্বপূর্ণ নোট

- **ব্যালান্স BST** (AVL Tree, Red-Black Tree) ব্যবহার করলে পারফরম্যান্স ভালো হয়
- **টাইম কমপ্লেক্সিটি:** 
  - Average Case: O(log n)
  - Worst Case: O(n)
- **স্পেস কমপ্লেক্সিটি:** O(n)

এই টিউটোরিয়ালটি BST বুঝতে আপনার সাহায্য করবে আশা করি! কোনো প্রশ্ন থাকলে জানাবেন।