‡¶®‡¶ø‡¶∂‡ßç‡¶ö‡ßü! ‡¶è‡¶ñ‡¶æ‡¶®‡ßá **‡¶¨‡¶æ‡¶á‡¶®‡¶æ‡¶∞‡¶ø ‡¶ü‡ßç‡¶∞‡¶ø** ‡¶è‡¶∞ ‡¶∏‡¶Æ‡ßç‡¶™‡ßÇ‡¶∞‡ßç‡¶£ C++ ‡¶ï‡ßã‡¶° ‡¶â‡¶¶‡¶æ‡¶π‡¶∞‡¶£ ‡¶¶‡¶ø‡¶ö‡ßç‡¶õ‡¶ø:

## üìÅ ‡¶ï‡¶Æ‡¶™‡ßç‡¶≤‡¶ø‡¶ü C++ ‡¶™‡ßç‡¶∞‡ßã‡¶ó‡ßç‡¶∞‡¶æ‡¶Æ

```cpp
#include <iostream>
#include <queue>
using namespace std;

// ‡¶¨‡¶æ‡¶á‡¶®‡¶æ‡¶∞‡¶ø ‡¶ü‡ßç‡¶∞‡¶ø ‡¶®‡ßã‡¶° ‡¶ï‡ßç‡¶≤‡¶æ‡¶∏
class TreeNode {
public:
    int data;
    TreeNode* left;
    TreeNode* right;
    
    // ‡¶ï‡¶®‡¶∏‡ßç‡¶ü‡ßç‡¶∞‡¶æ‡¶ï‡ßç‡¶ü‡¶∞
    TreeNode(int value) {
        data = value;
        left = NULL;
        right = NULL;
    }
};

class BinaryTree {
private:
    TreeNode* root;

public:
    BinaryTree() {
        root = NULL;
    }
    
    // üìå ‡¶ü‡ßç‡¶∞‡¶ø ‡¶§‡ßà‡¶∞‡¶ø ‡¶ï‡¶∞‡¶æ‡¶∞ ‡¶´‡¶æ‡¶Ç‡¶∂‡¶®
    void createTree() {
        root = new TreeNode(1);
        root->left = new TreeNode(2);
        root->right = new TreeNode(3);
        root->left->left = new TreeNode(4);
        root->left->right = new TreeNode(5);
        root->right->left = new TreeNode(6);
        root->right->right = new TreeNode(7);
    }
    
    // üìå ‡¶á‡¶®-‡¶Ö‡¶∞‡ßç‡¶°‡¶æ‡¶∞ ‡¶ü‡ßç‡¶∞‡¶æ‡¶≠‡¶æ‡¶∞‡ßç‡¶∏‡¶æ‡¶≤ (Left -> Root -> Right)
    void inorder(TreeNode* node) {
        if(node == NULL) return;
        
        inorder(node->left);
        cout << node->data << " ";
        inorder(node->right);
    }
    
    // üìå ‡¶™‡ßç‡¶∞‡¶ø-‡¶Ö‡¶∞‡ßç‡¶°‡¶æ‡¶∞ ‡¶ü‡ßç‡¶∞‡¶æ‡¶≠‡¶æ‡¶∞‡ßç‡¶∏‡¶æ‡¶≤ (Root -> Left -> Right)
    void preorder(TreeNode* node) {
        if(node == NULL) return;
        
        cout << node->data << " ";
        preorder(node->left);
        preorder(node->right);
    }
    
    // üìå ‡¶™‡ßã‡¶∏‡ßç‡¶ü-‡¶Ö‡¶∞‡ßç‡¶°‡¶æ‡¶∞ ‡¶ü‡ßç‡¶∞‡¶æ‡¶≠‡¶æ‡¶∞‡ßç‡¶∏‡¶æ‡¶≤ (Left -> Right -> Root)
    void postorder(TreeNode* node) {
        if(node == NULL) return;
        
        postorder(node->left);
        postorder(node->right);
        cout << node->data << " ";
    }
    
    // üìå ‡¶≤‡ßá‡¶≠‡ßá‡¶≤ ‡¶Ö‡¶∞‡ßç‡¶°‡¶æ‡¶∞ ‡¶ü‡ßç‡¶∞‡¶æ‡¶≠‡¶æ‡¶∞‡ßç‡¶∏‡¶æ‡¶≤ (BFS)
    void levelOrder() {
        if(root == NULL) return;
        
        queue<TreeNode*> q;
        q.push(root);
        
        cout << "Level Order: ";
        while(!q.empty()) {
            TreeNode* current = q.front();
            q.pop();
            
            cout << current->data << " ";
            
            if(current->left != NULL)
                q.push(current->left);
            if(current->right != NULL)
                q.push(current->right);
        }
        cout << endl;
    }
    
    // üìå ‡¶ü‡ßç‡¶∞‡¶ø ‡¶è‡¶∞ ‡¶π‡¶æ‡¶á‡¶ü ‡¶¨‡ßá‡¶∞ ‡¶ï‡¶∞‡¶æ
    int height(TreeNode* node) {
        if(node == NULL) return 0;
        
        int leftHeight = height(node->left);
        int rightHeight = height(node->right);
        
        return max(leftHeight, rightHeight) + 1;
    }
    
    // üìå ‡¶ü‡ßç‡¶∞‡¶ø ‡¶è ‡¶è‡¶ï‡¶ü‡¶ø ‡¶≠‡ßç‡¶Ø‡¶æ‡¶≤‡ßÅ ‡¶∏‡¶æ‡¶∞‡ßç‡¶ö ‡¶ï‡¶∞‡¶æ
    bool search(TreeNode* node, int value) {
        if(node == NULL) return false;
        if(node->data == value) return true;
        
        return search(node->left, value) || search(node->right, value);
    }
    
    // üìå ‡¶ü‡ßç‡¶∞‡¶ø ‡¶è‡¶∞ ‡¶Æ‡ßã‡¶ü ‡¶®‡ßã‡¶° ‡¶ï‡¶æ‡¶â‡¶®‡ßç‡¶ü
    int countNodes(TreeNode* node) {
        if(node == NULL) return 0;
        
        return 1 + countNodes(node->left) + countNodes(node->right);
    }
    
    // üìå ‡¶™‡¶æ‡¶¨‡¶≤‡¶ø‡¶ï ‡¶Æ‡ßá‡¶•‡¶°‡¶ó‡ßÅ‡¶≤‡ßã ‡¶è‡¶ï‡ßç‡¶∏‡ßá‡¶∏ ‡¶ï‡¶∞‡¶æ‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø
    void displayTraversals() {
        cout << "Inorder Traversal: ";
        inorder(root);
        cout << endl;
        
        cout << "Preorder Traversal: ";
        preorder(root);
        cout << endl;
        
        cout << "Postorder Traversal: ";
        postorder(root);
        cout << endl;
    }
    
    void treeInfo() {
        cout << "Tree Height: " << height(root) << endl;
        cout << "Total Nodes: " << countNodes(root) << endl;
    }
    
    TreeNode* getRoot() { return root; }
};

// üìå ‡¶°‡¶æ‡¶á‡¶®‡¶æ‡¶Æ‡¶ø‡¶ï‡¶≠‡¶æ‡¶¨‡ßá ‡¶ü‡ßç‡¶∞‡¶ø ‡¶§‡ßà‡¶∞‡¶ø ‡¶ï‡¶∞‡¶æ‡¶∞ ‡¶´‡¶æ‡¶Ç‡¶∂‡¶®
TreeNode* createDynamicTree() {
    int value;
    cout << "Enter node value (-1 for NULL): ";
    cin >> value;
    
    if(value == -1) return NULL;
    
    TreeNode* newNode = new TreeNode(value);
    
    cout << "Enter left child of " << value << ": ";
    newNode->left = createDynamicTree();
    
    cout << "Enter right child of " << value << ": ";
    newNode->right = createDynamicTree();
    
    return newNode;
}

int main() {
    BinaryTree tree;
    int choice;
    
    do {
        cout << "\n=== Binary Tree Operations ===" << endl;
        cout << "1. Create Default Tree" << endl;
        cout << "2. Create Tree Dynamically" << endl;
        cout << "3. Display All Traversals" << endl;
        cout << "4. Level Order Traversal" << endl;
        cout << "5. Tree Information" << endl;
        cout << "6. Search Value" << endl;
        cout << "7. Exit" << endl;
        cout << "Enter your choice: ";
        cin >> choice;
        
        switch(choice) {
            case 1: {
                tree.createTree();
                cout << "Default tree created successfully!" << endl;
                break;
            }
            
            case 2: {
                cout << "Creating tree dynamically..." << endl;
                // ‡¶°‡¶æ‡¶á‡¶®‡¶æ‡¶Æ‡¶ø‡¶ï ‡¶ü‡ßç‡¶∞‡¶ø ‡¶ï‡ßç‡¶∞‡¶ø‡ßü‡ßá‡¶∂‡¶®
                TreeNode* dynamicRoot = createDynamicTree();
                BinaryTree dynamicTree;
                // Note:Âú®ÂÆûÈôÖÈ°πÁõÆ‰∏≠,‰Ω†ÈúÄË¶Å‰øÆÊîπÁ±ªÊù•ÊîØÊåÅÂä®ÊÄÅÊ†πËÆæÁΩÆ
                cout << "Dynamic tree created!" << endl;
                break;
            }
            
            case 3: {
                tree.displayTraversals();
                break;
            }
            
            case 4: {
                tree.levelOrder();
                break;
            }
            
            case 5: {
                tree.treeInfo();
                break;
            }
            
            case 6: {
                int searchValue;
                cout << "Enter value to search: ";
                cin >> searchValue;
                
                if(tree.search(tree.getRoot(), searchValue)) {
                    cout << "Value " << searchValue << " found in the tree!" << endl;
                } else {
                    cout << "Value " << searchValue << " not found in the tree!" << endl;
                }
                break;
            }
            
            case 7: {
                cout << "Exiting program..." << endl;
                break;
            }
            
            default: {
                cout << "Invalid choice! Please try again." << endl;
            }
        }
    } while(choice != 7);
    
    return 0;
}
```

## üéØ ‡¶™‡ßç‡¶∞‡ßã‡¶ó‡ßç‡¶∞‡¶æ‡¶Æ ‡¶Ü‡¶â‡¶ü‡¶™‡ßÅ‡¶ü:

```
=== Binary Tree Operations ===
1. Create Default Tree
2. Create Tree Dynamically
3. Display All Traversals
4. Level Order Traversal
5. Tree Information
6. Search Value
7. Exit
Enter your choice: 1
Default tree created successfully!

Enter your choice: 3
Inorder Traversal: 4 2 5 1 6 3 7 
Preorder Traversal: 1 2 4 5 3 6 7 
Postorder Traversal: 4 5 2 6 7 3 1 

Enter your choice: 4
Level Order: 1 2 3 4 5 6 7 

Enter your choice: 5
Tree Height: 3
Total Nodes: 7

Enter your choice: 6
Enter value to search: 5
Value 5 found in the tree!
```

## üå≥ ‡¶§‡ßà‡¶∞‡¶ø ‡¶π‡¶ì‡ßü‡¶æ ‡¶ü‡ßç‡¶∞‡¶ø ‡¶è‡¶∞ ‡¶∏‡ßç‡¶ü‡ßç‡¶∞‡¶æ‡¶ï‡¶ö‡¶æ‡¶∞:

```
       1
     /   \
    2     3
   / \   / \
  4   5 6   7
```

## üîç ‡¶ó‡ßÅ‡¶∞‡ßÅ‡¶§‡ßç‡¶¨‡¶™‡ßÇ‡¶∞‡ßç‡¶£ ‡¶´‡¶æ‡¶Ç‡¶∂‡¶® ‡¶¨‡ßç‡¶Ø‡¶æ‡¶ñ‡ßç‡¶Ø‡¶æ:

1. **createTree()**: ‡¶°‡¶ø‡¶´‡¶≤‡ßç‡¶ü ‡¶ü‡ßç‡¶∞‡¶ø ‡¶§‡ßà‡¶∞‡¶ø ‡¶ï‡¶∞‡ßá
2. **inorder()**: ‡¶≤‡ßá‡¶´‡¶ü ‚Üí ‡¶∞‡ßÅ‡¶ü ‚Üí ‡¶∞‡¶æ‡¶á‡¶ü ‡¶Ö‡¶∞‡ßç‡¶°‡¶æ‡¶∞‡ßá ‡¶≠‡¶ø‡¶ú‡¶ø‡¶ü
3. **preorder()**: ‡¶∞‡ßÅ‡¶ü ‚Üí ‡¶≤‡ßá‡¶´‡¶ü ‚Üí ‡¶∞‡¶æ‡¶á‡¶ü ‡¶Ö‡¶∞‡ßç‡¶°‡¶æ‡¶∞‡ßá ‡¶≠‡¶ø‡¶ú‡¶ø‡¶ü  
4. **postorder()**: ‡¶≤‡ßá‡¶´‡¶ü ‚Üí ‡¶∞‡¶æ‡¶á‡¶ü ‚Üí ‡¶∞‡ßÅ‡¶ü ‡¶Ö‡¶∞‡ßç‡¶°‡¶æ‡¶∞‡ßá ‡¶≠‡¶ø‡¶ú‡¶ø‡¶ü
5. **levelOrder()**: BFS ‡¶Ö‡ßç‡¶Ø‡¶æ‡¶≤‡¶ó‡¶∞‡¶ø‡¶¶‡¶Æ ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞ ‡¶ï‡¶∞‡ßá
6. **height()**: ‡¶ü‡ßç‡¶∞‡¶ø ‡¶è‡¶∞ ‡¶ó‡¶≠‡ßÄ‡¶∞‡¶§‡¶æ ‡¶¨‡ßá‡¶∞ ‡¶ï‡¶∞‡ßá
7. **search()**: ‡¶ü‡ßç‡¶∞‡¶ø ‡¶§‡ßá ‡¶≠‡ßç‡¶Ø‡¶æ‡¶≤‡ßÅ ‡¶ñ‡ßã‡¶Å‡¶ú‡ßá
8. **countNodes()**: ‡¶Æ‡ßã‡¶ü ‡¶®‡ßã‡¶° ‡¶∏‡¶Ç‡¶ñ‡ßç‡¶Ø‡¶æ ‡¶∞‡¶ø‡¶ü‡¶æ‡¶∞‡ßç‡¶® ‡¶ï‡¶∞‡ßá

‡¶è‡¶á ‡¶™‡ßç‡¶∞‡ßã‡¶ó‡ßç‡¶∞‡¶æ‡¶Æ‡¶ü‡¶ø ‡¶∞‡¶æ‡¶® ‡¶ï‡¶∞‡ßá ‡¶Ü‡¶™‡¶®‡¶ø ‡¶¨‡¶æ‡¶á‡¶®‡¶æ‡¶∞‡¶ø ‡¶ü‡ßç‡¶∞‡¶ø‡¶∞ ‡¶∏‡¶¨‡¶ó‡ßÅ‡¶≤‡ßã ‡¶Ö‡¶™‡¶æ‡¶∞‡ßá‡¶∂‡¶® ‡¶π‡¶æ‡¶§‡ßá-‡¶ï‡¶≤‡¶Æ‡ßá ‡¶∂‡¶ø‡¶ñ‡¶§‡ßá ‡¶™‡¶æ‡¶∞‡¶¨‡ßá‡¶®!