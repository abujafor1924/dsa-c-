
#include <iostream>
#include <vector>
using namespace std;

/**
 * রোটেটেড সর্টেড অ্যারেতে টার্গেট এলিমেন্ট সার্চ করার ফাংশন
 * @param arr: রোটেটেড সর্টেড অ্যারে (ভেক্টর)
 * @param target: যে এলিমেন্ট খুঁজতে হবে
 * @return: টার্গেটের ইনডেক্স যদি পাওয়া যায়, নাহলে -1
 */
int searchInRotatedArray(const vector<int>& arr, int target) {
    // স্টেপ ১: ইনিশিয়ালাইজেশন - সার্চ স্পেস ডিফাইন করা
    int left = 0;                    // অ্যারের শুরু ইনডেক্স
    int right = arr.size() - 1;      // অ্যারের শেষ ইনডেক্স

    // স্টেপ ২: বাইনারি সার্চ লুপ - যতক্ষণ সার্চ স্পেস ভ্যালিড
    while (left <= right) {
        // স্টেপ ৩: মিড ইনডেক্স ক্যালকুলেট (ওভারফ্লো এড়ানোর জন্য)
        int mid = left + (right - left) / 2;
        // ব্যাখ্যা: (left + right) / 2 এর পরিবর্তে এই ফর্মুলা ব্যবহার করা হয়
        // কারণ left + right বড় সংখ্যা হলে ওভারফ্লো হতে পারে

        // স্টেপ ৪: চেক যদি মিড এলিমেন্টই টার্গেট হয়
        if (arr[mid] == target) {
            return mid; // টার্গেট পাওয়া গেছে, ইনডেক্স রিটার্ন করুন
        }

        // স্টেপ ৫: ডিটারমাইন কোন সাইড প্রপারলি সর্টেড
        // কেস ১: বাম অংশ সর্টেড (লেফ্ট থেকে মিড পর্যন্ত)
        if (arr[left] <= arr[mid]) {
            // ব্যাখ্যা: যদি arr[left] <= arr[mid] হয়, তাহলে 
            // লেফ্ট থেকে মিড পর্যন্ত সব এলিমেন্ট সর্টেড অর্ডারে আছে
            
            // স্টেপ ৬: চেক টার্গেট বাম সর্টেড অংশে আছে কিনা
            if (arr[left] <= target && target < arr[mid]) {
                // টার্গেট বাম সর্টেড অংশের রেঞ্জে আছে
                // [arr[left], arr[mid]) রেঞ্জে
                right = mid - 1; // সার্চ স্পেস বাম দিকে নিয়ে যান
            } else {
                // টার্গেট বাম সর্টেড অংশে নেই, তাই ডান অংশে আছে
                left = mid + 1; // সার্চ স্পেস ডান দিকে নিয়ে যান
            }
        } 
        // কেস ২: ডান অংশ সর্টেড (মিড থেকে রাইট পর্যন্ত)
        else {
            // ব্যাখ্যা: যদি arr[left] > arr[mid] হয়, তাহলে
            // ডান অংশ (মিড থেকে রাইট) সর্টেড অর্ডারে আছে
            
            // স্টেপ ৭: চেক টার্গেট ডান সর্টেড অংশে আছে কিনা
            if (arr[mid] < target && target <= arr[right]) {
                // টার্গেট ডান সর্টেড অংশের রেঞ্জে আছে
                // (arr[mid], arr[right]] রেঞ্জে
                left = mid + 1; // সার্চ স্পেস ডান দিকে নিয়ে যান
            } else {
                // টার্গেট ডান সর্টেড অংশে নেই, তাই বাম অংশে আছে
                right = mid - 1; // সার্চ স্পেস বাম দিকে নিয়ে যান
            }
        }
        
        // লুপ কন্টিনিউ হবে যতক্ষণ left <= right
        // প্রতিবার সার্চ স্পেস অর্ধেক হয়ে যাচ্ছে
    }

    // স্টেপ ৮: টার্গেট না পাওয়া গেলে
    return -1; // টার্গেট অ্যারেতে নেই
}


int main() {
    // স্টেপ ১: ইউজার থেকে ইনপুট নেওয়া
    int n, target;
    cout << "Enter number of elements in rotated sorted array: ";
    cin >> n;  // অ্যারের সাইজ ইনপুট নিন

    // স্টেপ ২: ডায়নামিক অ্যারে (ভেক্টর) তৈরি করা
    vector<int> arr(n);  // n সাইজের ভেক্টর ডিক্লেয়ারেশন
    
    // স্টেপ ৩: অ্যারে এলিমেন্টগুলি ইনপুট নেওয়া
    cout << "Enter " << n << " elements of the rotated sorted array: ";
    for (int i = 0; i < n; i++) {
        cin >> arr[i];  // প্রতিটি এলিমেন্ট ইউজার ইনপুট থেকে নিন
    }

    // স্টেপ ৪: টার্গেট ভ্যালু ইনপুট নেওয়া
    cout << "Enter target to search: ";
    cin >> target;  // যে ভ্যালু খুঁজতে হবে

    // স্টেপ ৫: সার্চ ফাংশন কল করা
    int result = searchInRotatedArray(arr, target);
    // ফাংশন কল এবং রেজাল্ট স্টোর করা

    // স্টেপ ৬: রেজাল্ট ডিসপ্লে করা
    if (result != -1) {
        // টার্গেট পাওয়া গেছে
        cout << "Element found at index: " << result << endl;
    } else {
        // টার্গেট পাওয়া যায়নি
        cout << "Element not found in the array." << endl;
    }

    // স্টেপ ৭: প্রোগ্রাম শেষ
    return 0;  // সাকসেসফুলি এক্সিকিউশন শেষ
}